# PR Reviewer Service

Микросервис для автоматического назначения ревьюеров на Pull Request’ы, управления командами и активностью пользователей.
---
### Заметки

1) **Заменил `id` (string) на `uuid`**
   - В PostgreSQL можно хранить как отдельный тип, который компактнее, чем `text`
   - Индексируется нативно
   - Удобно генерировать автоматически
   - [Почему именно выбрал данный тип (ссылка)](https://stackoverflow.com/questions/33836749/postgresql-using-uuid-vs-text-as-primary-key)

2) **Добавил автогенерацию `id` | сделал поле необязательным при создании**
   - Клиенту не нужно думать про идентификаторы
   - Сервис сам гарантирует уникальность и корректность `id`

3) **Опирался на архитектуру DDD**
   - В некоторых местах сознательно упростил, чтобы не тащить лишний оверхед для масштаба этого проекта
   - https://github.com/sklinkert/go-ddd

4) **Использовал Goose для миграций**
   - Транзакции "из коробки" -> снижается риск неконсистентного состояния БД
   - Удобные двунаправленные миграции (но в рамках проекта down посчитал излишим)
   - Автоматически создаётся служебная таблица с версией миграций

5) **Добавил использование транзакций при выполнении операций с БД**
   - Улучшает целостность данных
   - Обеспечивает атомарность для более сложных операций
   - Опирался на статью: https://habr.com/ru/articles/881918/

6) **Использовал чистые SQL-запросы вместо ORM**
   - Быстрее — нет оверхеда ORM
   - Надёжнее — полностью контролирую запросы | проще избегать N+1 и других неочевидных "оптимизаций" ORM
   - Легко смотреть `EXPLAIN ANALYZE` и точечно оптимизировать под PostgreSQL

7) **E2E-тесты через `testcontainers-go` с реальной PostgreSQL**
   - Поднимается временный контейнер с Postgres
   - Прогоняются те же миграции Goose
   - Тесты ходят в живой HTTP-API и проверяют полный сценарий (создание команд, PR, назначение/переназначение ревьюеров, merge)

8) **Роль сущности «команда»**
   - Из-за условия, что названия команд уникальны, структура БД становится довольно очевидной
   - Даже если мы добавляем `id` для команд, таблица команд почти ничего не хранит и по сути выступает «фабрикой» для массовой инициализации пользователей
   - Основная полезная нагрузка лежит на пользователях и PR, а сущность команды больше нужна для группировки и бизнес-логики, чем для сложного состояния в БД

---

## ТЗ

### Основные требования

- [x] Взаимодействие только через **HTTP API** (OpenAPI-спека `openapi.yml` в корне которую дали изначально, изменялась)
- [x] **Создание PR**: при создании назначаются до 2 активных ревьюеров из команды автора, исключая автора
- [x] **Переназначение ревьюера**: замена одного ревьюера на другого активного участника команды заменяемого ревьюера
- [x] **Запрет изменений после MERGED**: после merge списка ревьюеров изменить нельзя
- [x] **Учет isActive**: неактивные пользователи не назначаются на ревью и не выбираются для переназначения
- [x] **Идемпотентный merge**: повторный вызов `/pullRequest/merge` не падает, а возвращает текущее состояние PR
- [x] **Управление командами**: создание команды с участниками, получение команды по имени
- [x] **Управление пользователями**: смена статуса активности, получение списка PR пользователя
- [x] **PostgreSQL + миграции** через `goose`
- [x] **Запуск через `docker-compose up`**, сервис на порту `8080`
- [x] Применение миграций при старте сервиса

### Дополнительные задания

- [x] **Статистика** — эндпоинт `/stats/reviewers?team_name=...` с количеством назначений по ревьюерам в команде
- [x] **E2E-тестирование** — интеграционный тест полного сценария с использованием `testcontainers-go`
- [x] Нагрузочное тестирование (k6) — **реализовано**
- [x] Отдельно описанная конфигурация линтера 

---

```bash
docker-compose up --build
```

